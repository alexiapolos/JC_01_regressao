---
title: "Journal Club 1: Regress√£o Log√≠stica Bin√°ria"
subtitle: "Banco de dados: Breast cancer dataset"
author: "LiaaOnco"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 2
editor: 
  markdown: 
    wrap: 72
---

# Introdu√ß√£o

Nesta etapa aula pr√°tica, abordaremos a aplica√ß√£o do modelo de regress√£o
log√≠stica binaria no conjunto de dados **Breast Cancer Dataset**.<br>

**Fonte**: Wisconsin Diagnostic Breast Cancer (WDBC) dataset <br>
**Dispon√≠vel**: [Kaggle - Breast Cancer
Dataset](https://kaggle.com/datasets/uciml/breast-cancer-wisconsin-data).

## Carregamento de pacotes e dados

```{r, include = FALSE }

## Carregar pacotes 
library(tidyverse)
library(caret)
library(broom)
library(pROC)
```

```{r}
# Carregar o banco de dados previamente tratado
dados <- read.csv("breast-cancer.csv")

# Transformar a vari√°vel 'diagnosis' em bin√°ria (1 = maligno, 0 = benigno)
dados <- dados %>%
  mutate(diagnosis = ifelse(diagnosis == "M", 1, 0))

```

## Estrutura do banco de dados

```{r}
# Verificar a estrutura dos dados
glimpse(dados)
```

### Vari√°vel dependente (resposta)

'diagnosis': Indica se o n√≥dulo √© maligno ou benigno.<br>

### Vari√°veis independentes (explicativas)

Caracter√≠sticas calculadas a partir da imagem digitalizada de pun√ß√£o
aspirativa por agulha fina de uma massa mam√°ria. <br>

Dez caracter√≠sticas num√©ricas cont√≠nuas foram calculadas para cada
n√∫cleo celular:<br> a) Radius: M√©dia das dist√¢ncias do centro at√© os
pontos no per√≠metro.<br> b) Texture: Desvio padr√£o dos valores de escala
de cinza.<br> c) Perimeter: Per√≠metro.<br> d) Area: √Årea.<br> e)
Smoothness: Varia√ß√£o local nos comprimentos do raio.<br> f) Compactness:
perƒ±metro\^2 = √°rea - 1 <br> g) Concavity: Severidade das por√ß√µes
c√¥ncavas do contorno.<br> h) Concave points: N√∫mero de por√ß√µes c√¥ncavas
no contorno.<br> i) Symmetry: Simetria.<br> j) Fractal dimension:
Aproxima√ß√£o da "coastline" - 1 <br>

Para cada imagem, foram calculados a m√©dia (mean), o erro padr√£o (se) e
o "pior" (worst) valor dessas caracter√≠sticas, resultando em 30
atributos.

## Particionamento dos dados

Dividiremos os dados em dois conjuntos:

-   Treinamento: 80% dos dados.
-   Teste: 20% dos dados.

```{r}
set.seed(362)

# Criar √≠ndices para o particionamento
train_index <- createDataPartition(dados$diagnosis, p = 0.8, list = FALSE)

# Conjuntos de treinamento e teste
train_data <- dados[train_index, ]
test_data <- dados[-train_index, ]

# Verificar dimens√µes dos conjuntos
dim(train_data)
dim(test_data)
```

## Regress√£o Logistica Bin√°ria

**Objetivo:** Construir um modelo de regress√£o log√≠stica para prever a
probabilidade de um tumor ser maligno (Y=1) com base em caracter√≠sticas
cl√≠nicas.

### Modelagem

```{r}
# Ajuste do modelo
logistic_model <- glm(diagnosis ~ radius_mean + texture_mean + perimeter_mean, 
                      data = train_data, 
                      family = binomial)

# Resumo do modelo
summary(logistic_model)

```

O modelo foi ajustado. Ressalta-se que: <br>

-   'radius_mean' tem um efeito negativo significativo na probabilidade
    de malignidade.
-   'texture_mean' e 'perimeter_mean' apresentam efeitos positivos
    significativos na probabilidade de malignidade.

### Interpreta√ß√£o do coeficiente

Os coeficientes da regress√£o log√≠stica podem ser interpretadose ser
interpretados como o impacto das vari√°veis independentes na raz√£o de
chance (odds ratio). <br> Valores de ùõΩ\> 0 indicam aumento na
probabilidade de Y=1 (M), enquanto valores de Œ≤ \< 0 indicam redu√ß√£o na
probabilidade de Y=1 (M).

```{r}
# Calcular odds ratio e intervalos de confian√ßa
exp(cbind(Odds_Ratio = coef(logistic_model), confint(logistic_model)))
```

-   Para cada unidade em 'perimeter_mean', a raz√£o de chances de
    malignidade aumenta em 3 vezes.\<br\<

-   'radius_mean' reduz a chance de malignidade, enquanto 'texture_mean'
    aumenta ligeiramente essa probabilidade.

### Predi√ß√£o e avalia√ß√£o do modelo

```{r}
# Previs√£o
test_data <- test_data %>%
  mutate(predicted_prob = predict(logistic_model, newdata = test_data, type = "response"),
         predicted_class = ifelse(predicted_prob > 0.5, 1, 0))

ggplot(test_data, aes(x = radius_mean, y = diagnosis)) +
  geom_point(alpha = 0.6, color = "darkblue", aes(y = predicted_prob)) +  # Valores previstos
  geom_smooth(method = "glm", method.args = list(family = "binomial"), color = "firebrick") +
  labs(
    title = "Fun√ß√£o Log√≠stica",
    x = "Radius Mean",
    y = "Probabilidade de Malignidade"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
    axis.title = element_text(size = 14, face = "bold")
  )
```

### Matriz de confus√£o e m√©tricas de avalia√ß√£o

```{r}
# Criar a matriz de confus√£o
conf_matrix <- confusionMatrix(as.factor(test_data$predicted_class), as.factor(test_data$diagnosis))

# Exibir as m√©tricas
conf_matrix

```

O modelo apresentou bom desempenho geral, atingindo uma acur√°cia de
90,27% no conjunto de teste, com uma sensibilidade de 92,54% e uma
especificidade de 86,96%.

### Visualiza√ß√£o

```{r}
# Converter a tabela da matriz de confus√£o para um dataframe
conf_matrix_df <- as.data.frame(conf_matrix$table)

# Plotar a matriz de confus√£o
ggplot(conf_matrix_df, aes(x = Prediction, y = Reference, fill = Freq)) +
  geom_tile(alpha = 0.8) +
  scale_fill_gradient(low = "#cdd3e0", high = "#032263") +
  geom_text(aes(label = Freq), color = "black", size = 6) +
  labs(
    title = "Matriz de Confus√£o",
    x = "Classe Predita",
    y = "Classe Real",
    fill = "Frequ√™ncia"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
    axis.title = element_text(size = 14, face = "bold")
  )

```

### Curva ROC e AUC

A **curva ROC** mede a capacidade do modelo de distinguir entre classes,
enquanto a **AUC** (√°rea sob a curva) quantifica essa capacidade.

```{r}
# Gerar a curva ROC
roc_curve <- roc(test_data$diagnosis, test_data$predicted_prob)

# Plotar a curva ROC
plot(roc_curve, col = "darkblue", main = "Curva ROC")
abline(a = 0, b = 1, col = "firebrick", lty = 2)

# Exibir o valor da AUC
auc(roc_curve)

```

A curva ROC mostrou uma AUC de 0,9708, indicando uma capacidade
discriminat√≥ria do modelo em diferenciar n√≥dulos benignos de malignos.
