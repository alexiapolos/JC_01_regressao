setwd("~/github/JC_01_regressao")
# Carregar pacotes
library(tidyverse)
library(ggplot2)
library(ggpmisc)
library(tidyverse)
library(ggplot2)
library(ggpmisc)
library(caret)
library(broom)
# Carregar e limpar os dados
dados <- read.csv("heart.csv") %>%
rename(
idade = age,
sexo = sex,
tipo_dor_toracica = cp,
pressao_repouso = trestbps,
colesterol = chol,
glicose_jejum = fbs,
ecg_repouso = restecg,
freq_cardiaca_max = thalach,
angina_exercicio = exang,
depressao_st = oldpeak,
incl_st = slope,
vasos_coloridos = ca,
thal = thal,
doenca_cardiaca = target
) %>%
mutate(
sexo = factor(sexo, levels = c(0, 1), labels = c("Feminino", "Masculino")),
tipo_dor_toracica = factor(tipo_dor_toracica, levels = 0:3,
labels = c("Angina típica", "Angina atípica", "Dor não anginosa", "Assintomático")),
glicose_jejum = factor(glicose_jejum, levels = c(0, 1), labels = c("<= 120 mg/dl", "> 120 mg/dl")),
ecg_repouso = factor(ecg_repouso, levels = 0:2,
labels = c("Normal", "Anormalidade ST-T", "Hipertrofia ventricular esquerda")),
angina_exercicio = factor(angina_exercicio, levels = c(0, 1), labels = c("Não", "Sim")),
incl_st = factor(incl_st, levels = 0:2,
labels = c("Descendente", "Plano", "Ascendente")),
vasos_coloridos = factor(vasos_coloridos, levels = 0:3,
labels = c("0 vasos", "1 vaso", "2 vasos", "3 vasos")),
thal = factor(thal, levels = c(0, 1, 2, 3),
labels = c("Normal", "Defeito fixo", "Defeito reversível", "Desconhecido")),
doenca_cardiaca = factor(doenca_cardiaca, levels = c(0, 1), labels = c("Ausente", "Presente"))
)
# Verificar a estrutura dos dados
glimpse(dados)
set.seed(362)
# Particionamento
train_index <- sample(1:nrow(dados), size = 0.8 * nrow(dados))
train_data <- dados[train_index, ]
test_data <- dados[-train_index, ]
dim(train_data)
dim(test_data)
# Ajuste do modelo
linear_model <- lm(colesterol ~ pressao_repouso, data = train_data)
# Resumo do modelo
summary(linear_model)
# Previsão
linear_preds <- test_data %>%
mutate(pred = predict(linear_model, newdata = test_data))
# Desempenho
linear_metrics <- linear_preds %>%
summarise(
R2 = cor(colesterol, pred)^2,
RMSE = sqrt(mean((colesterol - pred)^2))
)
linear_metrics
ggplot(train_data, aes(x = pressao_repouso, y = colesterol)) +
geom_point(color = "darkblue", size = 2, alpha = 0.8) +
geom_smooth(method = "lm", color = "firebrick", se = TRUE) +
labs(
title = "Regressão Linear Simples",
x = "Pressão Arterial em Repouso",
y = "Colesterol Sérico"
) +
theme_minimal()
# Ajuste do modelo
multiple_model <- lm(colesterol ~ idade + sexo + pressao_repouso + freq_cardiaca_max, data = train_data)
# Resumo do modelo
summary(multiple_model)
# Previsão
multiple_preds <- test_data %>%
mutate(pred = predict(multiple_model, newdata = test_data))
# Desempenho
multiple_metrics <- multiple_preds %>%
summarise(
R2 = cor(colesterol, pred)^2,
RMSE = sqrt(mean((colesterol - pred)^2))
)
multiple_metrics
library(plotly)
grid_data <- expand.grid(
idade = seq(min(train_data$idade), max(train_data$idade), length.out = 50),
pressao_repouso = seq(min(train_data$pressao_repouso), max(train_data$pressao_repouso), length.out = 50)
)
# Previsão com base nos valores do grid
grid_data$colesterol_pred <- predict(multiple_model, newdata = grid_data)
# Ajuste do modelo
multiple_model <- lm(colesterol ~ idade + sexo + pressao_repouso + freq_cardiaca_max, data = train_data)
# Resumo do modelo
summary(multiple_model)
# Previsão
multiple_preds <- test_data %>%
mutate(pred = predict(multiple_model, newdata = test_data))
# Desempenho
multiple_metrics <- multiple_preds %>%
summarise(
R2 = cor(colesterol, pred)^2,
RMSE = sqrt(mean((colesterol - pred)^2))
)
multiple_metrics
grid_data <- expand.grid(
idade = seq(min(train_data$idade), max(train_data$idade), length.out = 50),
pressao_repouso = seq(min(train_data$pressao_repouso), max(train_data$pressao_repouso), length.out = 50)
)
# Previsão com base nos valores do grid
grid_data$colesterol_pred <- predict(multiple_model, newdata = grid_data)
grid_data <- expand.grid(
idade = seq(min(train_data$idade), max(train_data$idade), length.out = 50),
pressao_repouso = seq(min(train_data$pressao_repouso), max(train_data$pressao_repouso), length.out = 50)
)
# Adicionar sexo ao grid (fixado como "Masculino" ou "Feminino")
grid_data$sexo <- "Masculino"  # Escolha um nível fixo, ou "Feminino"
# Adicionar uma frequência cardíaca média como exemplo
grid_data$freq_cardiaca_max <- mean(train_data$freq_cardiaca_max, na.rm = TRUE)
# Previsão com base nos valores do grid
grid_data$colesterol_pred <- predict(multiple_model, newdata = grid_data)
# Gráfico interativo 3D com plotly
fig <- plot_ly()
# Adicionar pontos reais
fig <- fig %>%
add_markers(
x = train_data$idade,
y = train_data$pressao_repouso,
z = train_data$colesterol,
marker = list(color = "red", size = 3),
name = "Dados Reais"
)
# Adicionar superfície do modelo
fig <- fig %>%
add_surface(
x = ~unique(grid_data$idade),
y = ~unique(grid_data$pressao_repouso),
z = ~matrix(grid_data$colesterol_pred, nrow = 50),
colorscale = "Viridis",
opacity = 0.7,
name = "Modelo"
)
# Ajustar layout
fig <- fig %>%
layout(
scene = list(
xaxis = list(title = "Idade"),
yaxis = list(title = "Pressão de Repouso"),
zaxis = list(title = "Colesterol")
)
)
# Exibir gráfico
fig
grid_data <- expand.grid(
idade = seq(min(train_data$idade), max(train_data$idade), length.out = 50),
pressao_repouso = seq(min(train_data$pressao_repouso), max(train_data$pressao_repouso), length.out = 50)
)
# Adicionar sexo ao grid (fixado como "Masculino" ou "Feminino")
grid_data$sexo <- "Masculino"  # Escolha um nível fixo, ou "Feminino"
# Adicionar uma frequência cardíaca média como exemplo
grid_data$freq_cardiaca_max <- mean(train_data$freq_cardiaca_max, na.rm = TRUE)
# Previsão com base nos valores do grid
grid_data$colesterol_pred <- predict(multiple_model, newdata = grid_data)
# Gráfico interativo 3D com plotly
fig <- plot_ly()
# Adicionar pontos reais
fig <- fig %>%
add_markers(
x = train_data$idade,
y = train_data$pressao_repouso,
z = train_data$colesterol,
marker = list(color = "red", size = 3),
name = "Dados Reais"
)
# Adicionar superfície do modelo
fig <- fig %>%
add_surface(
x = ~unique(grid_data$idade),
y = ~unique(grid_data$pressao_repouso),
z = ~matrix(grid_data$colesterol_pred, nrow = 50),
colorscale = "Viridis",
opacity = 0.7,
colorbar = list(title = "$colesterol$")  # Título da legenda
name = "Modelo"
# Adicionar superfície do modelo
fig <- fig %>%
add_surface(
x = ~unique(grid_data$idade),
y = ~unique(grid_data$pressao_repouso),
z = ~matrix(grid_data$colesterol_pred, nrow = 50),
colorscale = "Viridis",
opacity = 0.7,
colorbar = list(title = "$colesterol$"),  # Título da legenda
name = "Modelo"
)
setwd("~/github/JC_01_regressao")
## Carregar pacotes
library(tidyverse)
library(ggplot2)
library(ggpmisc)
library(tidyverse)
library(ggplot2)
library(ggpmisc)
library(caret)
library(broom)
library(plotly)
# Carregar o banco de dados mtcars
dados <- mtcars %>%
rownames_to_column(var = "carro") %>%
mutate(
am = factor(am, levels = c(0, 1), labels = c("Automático", "Manual")),
cyl = as.factor(cyl),
vs = factor(vs, levels = c(0, 1), labels = c("V-shaped", "Straight"))
)
set.seed(362)
# Particionamento
train_index <- sample(1:nrow(dados), size = 0.8 * nrow(dados))
train_data <- dados[train_index, ]
test_data <- dados[-train_index, ]
dim(train_data)
dim(test_data)
# Ajuste do modelo
linear_model <- lm(mpg ~ wt, data = train_data)
# Resumo do modelo
summary(linear_model)
# Previsão
linear_preds <- test_data %>%
mutate(pred = predict(linear_model, newdata = test_data))
# Desempenho
linear_metrics <- linear_preds %>%
summarise(
R2 = cor(mpg, pred)^2,
RMSE = sqrt(mean((mpg - pred)^2))
)
linear_metrics
ggplot(train_data, aes(x = wt, y = mpg)) +
geom_point(color = "darkblue", size = 2, alpha = 0.8) +
geom_smooth(method = "lm", color = "firebrick", se = TRUE) +
labs(
title = "Regressão Linear Simples",
x = "Peso do Carro (wt)",
y = "Eficiência de Combustível (mpg)"
) +
theme_minimal()
# Ajuste do modelo
multiple_model <- lm(mpg ~ wt + hp + cyl, data = train_data)
# Resumo do modelo
summary(multiple_model)
# Previsão
multiple_preds <- test_data %>%
mutate(pred = predict(multiple_model, newdata = test_data))
# Desempenho
multiple_metrics <- multiple_preds %>%
summarise(
R2 = cor(mpg, pred)^2,
RMSE = sqrt(mean((mpg - pred)^2))
)
multiple_metrics
# Gerar grid para variáveis contínuas
grid_data <- expand.grid(
wt = seq(min(train_data$wt), max(train_data$wt), length.out = 50),
hp = seq(min(train_data$hp), max(train_data$hp), length.out = 50)
)
# Adicionar valores fixos para outras variáveis (se necessário)
grid_data$cyl <- mean(train_data$cyl, na.rm = TRUE)  # Usando a média para "cyl"
# Previsão com base nos valores do grid
grid_data$mpg_pred <- predict(multiple_model, newdata = grid_data)
# Gerar grid para variáveis contínuas
grid_data <- expand.grid(
wt = seq(min(train_data$wt), max(train_data$wt), length.out = 50),
hp = seq(min(train_data$hp), max(train_data$hp), length.out = 50)
)
# Adicionar valores fixos para a variável categórica (fator)
grid_data$cyl <- factor("4", levels = levels(train_data$cyl))  # Escolha um nível válido de 'cyl'
# Previsão com base nos valores do grid
grid_data$mpg_pred <- predict(multiple_model, newdata = grid_data)
# Gráfico interativo 3D com plotly
fig <- plot_ly()
# Adicionar pontos reais
fig <- fig %>%
add_markers(
x = train_data$wt,
y = train_data$hp,
z = train_data$mpg,
marker = list(color = "red", size = 3),
name = "Dados Reais"
)
# Adicionar superfície do modelo
fig <- fig %>%
add_surface(
x = ~unique(grid_data$wt),
y = ~unique(grid_data$hp),
z = ~matrix(grid_data$mpg_pred, nrow = 50),
colorscale = "Viridis",
opacity = 0.7,
colorbar = list(title = "$mpg$")  # Título da legenda
)
# Ajustar layout
fig <- fig %>%
layout(
scene = list(
xaxis = list(title = "Peso (wt)"),
yaxis = list(title = "Potência (hp)"),
zaxis = list(title = "MPG")
)
)
fig
